// Shelly Hydroponic Pump Controller Script v1.2 (Configurable Messages)
// ------------------------------------------------------------------------------------------
// This script controls a pump (connected to Shelly Switch 0) for a hydroponic system.
// It uses continuous ON/OFF cycles with different durations for day and night.
// Day/Night periods are determined by fixed hours configured below.
// Includes advanced Telegram notifications (configurable messages) and optional Uptime Kuma heartbeat pings.
//
// AUTHOR: themarv1 (KI-Assistet by Gemini)
// VERSION: 1.2 (Configurable Messages)
// DATE: 2025-04-29 // Updated Date
//
// PLEASE ADJUST CONFIGURATION AND TEST THOROUGHLY! USE AT YOUR OWN RISK.
// ------------------------------------------------------------------------------------------

// --- GENERAL CONFIGURATION ---
let CONFIG_SWITCH_ID = 0;

// --- Fixed Day/Night Times ---
let CONFIG_DAY_START_HOUR = 6;
let CONFIG_DAY_END_HOUR = 18;

// --- Cycle Duration Configuration ---
let CONFIG_DAY_ON_MIN = 15;
let CONFIG_DAY_OFF_MIN = 45;
let CONFIG_NIGHT_ON_MIN = 15;
let CONFIG_NIGHT_OFF_MIN = 180;

// --- NOTIFICATION CONFIGURATION ---
let CONFIG_ENABLE_NOTIFICATIONS = true;
let CONFIG_TELEGRAM_BOT_TOKEN = "DEIN_BOT_TOKEN_HIER_EINFUEGEN"; // !! REPLACE !!
let CONFIG_TELEGRAM_CHAT_ID = "DEINE_CHAT_ID_HIER_EINFUEGEN";   // !! REPLACE !!
let CONFIG_DEBUG_PUMP_NOTIFICATIONS = false;
let CONFIG_DAILY_STATUS_HOUR = 8;

// --- UPTIME KUMA CONFIGURATION ---
let CONFIG_UPTIME_KUMA_ENABLE = false;
let CONFIG_UPTIME_KUMA_PUSH_URL = "YOUR_UPTIME_KUMA_PUSH_URL_HERE"; // !! REPLACE if enabled !!
let CONFIG_UPTIME_KUMA_INTERVAL_SEC = 300;

// --- NOTIFICATION MESSAGES (Editable Templates) ---
// You can edit the text here. Use <b>...</b> for bold.
// Placeholders like {MODE}, {PUMP_STATE}, {CYCLE_INFO}, {DELAY_SEC} will be replaced by the script.
let CONFIG_MSG_STARTUP = "‚úÖ <b>Hydroponic Script Started</b>\nInitial Mode: {MODE}";
let CONFIG_MSG_MODE_SWITCH = "‚ÑπÔ∏è Switching to <b>{MODE} Mode</b> (Cycles: {CYCLE_INFO} Min).";
let CONFIG_MSG_DAILY_STATUS = "<b>‚ÑπÔ∏è Daily Status</b>\nMode: {MODE}\nPump: {PUMP_STATE}\nScript running OK.";
let CONFIG_MSG_DEBUG_ON = "‚öôÔ∏è DEBUG: Pump turned ON (Cycle).";
let CONFIG_MSG_DEBUG_OFF = "‚öôÔ∏è DEBUG: Pump turned OFF (Cycle).";
let CONFIG_MSG_TIMER_ERROR = "<b>üö® CRITICAL ERROR: Timer Delay Zero!</b>\nCycle stopped. Pump might be stuck ON or OFF.\nDetails: Invalid Delay = {DELAY_SEC}s";

// --- END CONFIGURATION ---

// Global Variables
let timerHandle = null;
let isCurrentlyOn = false;
let notificationSent = false;
let wasPreviouslyDayTime = null;
let dailyStatusTimerHandle = null;
let kumaTimerHandle = null;

// Function to escape HTML characters (manual version)
function escapeHtml(text) { /* ... unchanged ... */
    if (typeof text !== 'string') { return text; } let result = ""; for (let i = 0; i < text.length; i++) { let char = text[i]; if (char === '&') { result += '&amp;'; } else if (char === '<') { result += '&lt;'; } else if (char === '>') { result += '&gt;'; } else { result += char; } } return result;
}

// Function to send a notification via Telegram Bot API
function sendNotification(message, isSilent) { // Message now comes fully formatted
  // ... (Function content remains the same as v8.3 - sends the raw message) ...
   isSilent = (typeof isSilent === 'boolean' && isSilent); if (!CONFIG_ENABLE_NOTIFICATIONS || CONFIG_TELEGRAM_BOT_TOKEN === "DEIN_BOT_TOKEN_HIER_EINFUEGEN" || CONFIG_TELEGRAM_CHAT_ID === "DEINE_CHAT_ID_HIER_EINFUEGEN") { print("Notifications disabled or Bot Token/Chat ID not configured."); return; } if (notificationSent && !isSilent && (message.indexOf("Timer delay") !== -1 || message.indexOf("Error") !== -1 || message.indexOf("ERROR") !== -1 )) { print("Notification already sent for current error state. Skipping duplicate LOUD error message."); return; } print((isSilent ? "(Silent) " : "(LOUD) ") + "Sending Telegram notification: " + message); let telegramUrl = "https://api.telegram.org/bot" + CONFIG_TELEGRAM_BOT_TOKEN + "/sendMessage"; let payload = { chat_id: CONFIG_TELEGRAM_CHAT_ID, text: message, parse_mode: "HTML" }; if (isSilent) { payload.disable_notification = true; } if (!isSilent) { notificationSent = false; } Shelly.call("HTTP.POST", { url: telegramUrl, headers: { "Content-Type": "application/json" }, body: JSON.stringify(payload), timeout: 15, ssl_ca: "*" }, function(res, error_code, error_msg) { let success = false; if (error_code === 0 && res && res.code === 200) { let rb = null; try { rb = JSON.parse(res.body); if (rb.ok === true) { success = true; } } catch (e) { print("Could not parse Telegram response as JSON."); } } if (success) { print("Telegram notification sent successfully."); } else { print("Error sending Telegram notification: Code=" + error_code + ", Msg=" + error_msg + ", HTTP-Code=" + (res ? res.code : "N/A") + ", Body: " + (res ? res.body : "N/A")); if (!isSilent) { notificationSent = true; print("Set notificationSent flag due to LOUD message failure."); } } });
}

// Uptime Kuma Heartbeat function
function sendUptimeKumaHeartbeat() { /* ... unchanged ... */
    if (!CONFIG_UPTIME_KUMA_ENABLE || CONFIG_UPTIME_KUMA_PUSH_URL === "YOUR_UPTIME_KUMA_PUSH_URL_HERE" || CONFIG_UPTIME_KUMA_PUSH_URL.length < 15) { return; } print("Sending Uptime Kuma heartbeat..."); Shelly.call("HTTP.GET", { url: CONFIG_UPTIME_KUMA_PUSH_URL, timeout: 10 }, function (res, error_code, error_msg) { if (!(error_code === 0 && res && res.code === 200)) { print("Error sending Uptime Kuma heartbeat: Code=" + error_code + ", Msg=" + error_msg + ", HTTP-Code=" + (res ? res.code : "N/A")); } });
}

// Main function for the pump cycle (MODIFIED: Constructs messages from config)
function runPumpCycle() {
  if (timerHandle !== null) { Timer.clear(timerHandle); timerHandle = null; }
  let currentOnDurationMin = 0; let currentOffDurationMin = 0; let mode = ""; let timeNow = new Date(); let currentHour = timeNow.getHours();
  let isDayTime = (currentHour >= CONFIG_DAY_START_HOUR && currentHour < CONFIG_DAY_END_HOUR);

  // Check for Day/Night switch and send SILENT notification
  if (wasPreviouslyDayTime !== null && isDayTime !== wasPreviouslyDayTime) {
    let newMode = isDayTime ? "Day" : "Night";
    let cycleInfo = isDayTime ? CONFIG_DAY_ON_MIN + "/" + CONFIG_DAY_OFF_MIN : CONFIG_NIGHT_ON_MIN + "/" + CONFIG_NIGHT_OFF_MIN;
    // *** Construct message from template ***
    let switchMessage = CONFIG_MSG_MODE_SWITCH
                          .replace("{MODE}", newMode)
                          .replace("{CYCLE_INFO}", cycleInfo);
    sendNotification(switchMessage, true); // true = Silent
  }
  wasPreviouslyDayTime = isDayTime;

  // Set cycle durations
  if (isDayTime) { /* ... set day times ... */ mode = "Day (Fixed Times)"; } else { /* ... set night times ... */ mode = "Night (Fixed Times)"; }
  print("Hydroponic Cycle: Mode: " + mode + ". Cycle: " + currentOnDurationMin + "min ON / " + currentOffDurationMin + "min OFF.");

  // Determine next action and execute
  let nextTimerDelaySec = 0; let nextActionIsOn = !isCurrentlyOn;

  if (nextActionIsOn) { // Switch Pump ON
    print("Switching pump ON.");
    Shelly.call("Switch.Set", {'id': CONFIG_SWITCH_ID, 'on': true}, function(res, err_code, err_msg){
        if(err_code === 0){ print("Hydroponic Cycle: Pump switched ON.");
            // *** Use message from config ***
            if (CONFIG_DEBUG_PUMP_NOTIFICATIONS) { sendNotification(CONFIG_MSG_DEBUG_ON, true); }
        } else { print("ERROR switching pump ON: Code "+err_code + ", Msg: "+err_msg);}
   });
    isCurrentlyOn = true; nextTimerDelaySec = currentOnDurationMin * 60; print("Hydroponic Cycle: Next action (OFF) scheduled in " + currentOnDurationMin + " minutes.");
  } else { // Switch Pump OFF
    print("Switching pump OFF.");
    Shelly.call("Switch.Set", {'id': CONFIG_SWITCH_ID, 'on': false}, function(res, err_code, err_msg){
        if(err_code === 0){ print("Hydroponic Cycle: Pump switched OFF.");
             // *** Use message from config ***
            if (CONFIG_DEBUG_PUMP_NOTIFICATIONS) { sendNotification(CONFIG_MSG_DEBUG_OFF, true); }
        } else { print("ERROR switching pump OFF: Code "+err_code + ", Msg: "+err_msg);}
   });
    isCurrentlyOn = false; nextTimerDelaySec = currentOffDurationMin * 60; print("Hydroponic Cycle: Next action (ON) scheduled in " + currentOffDurationMin + " minutes.");
  }

  // Set timer for the next execution
  if (nextTimerDelaySec > 0) { timerHandle = Timer.set(nextTimerDelaySec * 1000, false, runPumpCycle); }
  else { // Handle timer error
      print("Hydroponic Cycle: Error - Timer delay is zero or negative. Stopping cycle.");
      notificationSent = false; // Reset for LOUD error message
      // *** Construct message from template ***
      let errorMsg = CONFIG_MSG_TIMER_ERROR.replace("{DELAY_SEC}", nextTimerDelaySec);
      sendNotification(errorMsg, false); // false = LOUD
  }
}

// Function to send the daily status report (MODIFIED: Constructs message from config)
function sendDailyStatus() {
  let timeNow = new Date(); let currentHour = timeNow.getHours(); let isDayTime = (currentHour >= CONFIG_DAY_START_HOUR && currentHour < CONFIG_DAY_END_HOUR);
  let currentMode = isDayTime ? "Day (Fixed Times)" : "Night (Fixed Times)";
  Shelly.call("Switch.GetStatus", {'id': CONFIG_SWITCH_ID}, function(result){
      let pumpState = "Unknown"; if(result && typeof result.output !== 'undefined'){ pumpState = result.output ? "ON" : "OFF"; } else if (result && typeof result.ison !== 'undefined'){ pumpState = result.ison ? "ON" : "OFF"; }
      // *** Construct message from template ***
      let message = CONFIG_MSG_DAILY_STATUS
                      .replace("{MODE}", currentMode)
                      .replace("{PUMP_STATE}", pumpState);
      print("Sending daily status report...");
      sendNotification(message, true); // true = Silent
  });
}

// Function to initialize timers and start the first cycle (MODIFIED: Constructs message from config)
function initializeCycle() {
    print("Hydroponic Cycle Script (Cycles, Adv. Notify, Kuma, Config Msgs): Initializing...");
    notificationSent = false;

    // Set initial Day/Night state
    let initTime = new Date(); let initHour = initTime.getHours();
    wasPreviouslyDayTime = (initHour >= CONFIG_DAY_START_HOUR && initHour < CONFIG_DAY_END_HOUR);
    let initialMode = wasPreviouslyDayTime ? "Day" : "Night"; // Use English "Day"/"Night" here
    print("Initial mode determined: " + initialMode);

    // Schedule the daily status timer
    // ... (unchanged scheduling logic) ...
    if (dailyStatusTimerHandle !== null) Timer.clear(dailyStatusTimerHandle); let now = new Date(); let targetTimeToday = new Date(now.getFullYear(), now.getMonth(), now.getDate(), CONFIG_DAILY_STATUS_HOUR, 0, 0, 0); let msToTarget = targetTimeToday.getTime() - now.getTime(); if (msToTarget < 0) { msToTarget += 24 * 60 * 60 * 1000; } dailyStatusTimerHandle = Timer.set(msToTarget, true, sendDailyStatus); print("Daily status report scheduled for " + CONFIG_DAILY_STATUS_HOUR + ":00 (next run in approx. " + Math.round(msToTarget/60000) + " min).");

    // Schedule Uptime Kuma Heartbeat Timer
    // ... (unchanged scheduling logic) ...
    if (kumaTimerHandle !== null) { Timer.clear(kumaTimerHandle); } if (CONFIG_UPTIME_KUMA_ENABLE && CONFIG_UPTIME_KUMA_PUSH_URL !== "YOUR_UPTIME_KUMA_PUSH_URL_HERE" && CONFIG_UPTIME_KUMA_PUSH_URL.length > 15) { let intervalMs = Math.max(CONFIG_UPTIME_KUMA_INTERVAL_SEC, 60) * 1000; Timer.set(1000, false, sendUptimeKumaHeartbeat); kumaTimerHandle = Timer.set(intervalMs, true, sendUptimeKumaHeartbeat); print("Uptime Kuma heartbeat scheduled every " + (intervalMs / 1000) + " seconds."); } else { print("Uptime Kuma heartbeat disabled or URL not configured."); }

    // Short delay, then start first cycle AND send LOUD startup notification
    print("Hydroponic Cycle: Waiting briefly (3 sec)...");
    Timer.set(3000, false, function() {
        print("Hydroponic Cycle Script: Starting first cycle run.");
        Shelly.call("Switch.Set", {'id': CONFIG_SWITCH_ID, 'on': false}, function() {
            isCurrentlyOn = false; runPumpCycle(); // Start the first cycle run

            // Send LOUD startup notification using template
            if (CONFIG_ENABLE_NOTIFICATIONS && CONFIG_TELEGRAM_BOT_TOKEN !== "DEIN_BOT_TOKEN_HIER_EINFUEGEN" && CONFIG_TELEGRAM_CHAT_ID !== "DEINE_CHAT_ID_HIER_EINFUEGEN") {
                notificationSent = false; // Reset for LOUD startup message
                // *** Construct message from template ***
                let startMessage = CONFIG_MSG_STARTUP.replace("{MODE}", initialMode);
                sendNotification(startMessage, false); // false = LOUD
            }
        });
    });
}

// --- Script Start ---
initializeCycle();
